function getDataMetaFeatures(folder, varargin)
% getDataMetaFeatures(folder, settings) calculates metafeatures on large 
% set of data
% 
% Input:
%   folder   - data input folder or file
%   settings - pairs of property (string) and value, or struct with 
%              properties as fields:
%     'Design'    - sampling design of source data (use only if data was 
%                   generated by using one) | {'lhs', 'ilhs', 'lhsnorm'}
%     'MetaInput' - input sets for metafeature calculation | {'archive',
%                   'test', 'train', 'traintest'}
%     'Output'    - output folder | string
%     'Rewrite'   - rewrite already computed results | boolean | false
%     'TrainOpts' - training set options | structure with fields 
%                   evoControlTrainNArchivePoints, evoControlTrainRange,
%                   trainRange, trainsetSizeMax, and trainSetType
%     'TransData' - transformation of data | {'none', 'cma'}
%                     'none' - raw data X are used for calculation
%                     'cma'  - X_t = ( (sigma * BD) \ X')';
%                 - should have the same lenght as 'MetaInput'
%
% See Also:
%   getMetaFeatures, testModels

  
  if nargin < 1
    help getDataMetaFeatures
    return
  end
  
  listFeatures = {'basic', ...
              'cm_angle', ...
              'cm_convexity', ...
              'cm_gradhomo', ...
              'cmaes', ...
              'dispersion', ...
              'ela_distribution', ...
              'ela_levelset', ...
              'ela_metamodel', ...
              'gcm', ...
              'infocontent', ...
              'linear_model', ...
              'nearest_better', ...
              'pca' ...
             };
  
  % parse settings
  settings = settings2struct(varargin{:});
  design = defoptsi(settings, 'Design', '');
  % parse options
  opts.lb = defopts(settings, 'lb', '-5*ones(1, dim)');
  opts.ub = defopts(settings, 'ub', ' 5*ones(1, dim)');
  opts.dim = defoptsi(settings, 'dim', []);
  opts.features = defoptsi(settings, 'features', listFeatures);
  opts.fun       = defoptsi(settings, 'Fun', []);
  opts.inst      = defoptsi(settings, 'Instances', []);
  opts.metaInput = defoptsi(settings, 'MetaInput', {'archive'});
  opts.rewrite   = defoptsi(settings, 'Rewrite', false);
  opts.trainOpts = defoptsi(settings, 'TrainOpts', struct());
  opts.transform = defoptsi(settings, 'TransData', {'none'});
  if ~iscell(opts.transform)
    opts.transform = {opts.transform};
  end
  % not enough transformation settings -> fill with no transformation
  if numel(opts.metaInput) > numel(opts.transform)
    opts.transform(end+1 : numel(opts.metaInput)) = {'none'};
  end
  
  % direct calculation of data -> input is structure
  if isstruct(folder)
    fun = opts.fun;
    dim = opts.dim;
    inst = opts.inst;
    fileString = sprintf('data_f%d_%dD_i%d_fts.mat', fun, dim, inst);
    outputFile = defoptsi(settings, 'Output', fileString);
    if opts.rewrite || ~isfile(outputFile) 
      res = getSingleDataMF(folder, opts);
    end
    % save results
    save(outputFile, 'res', 'fun', 'dim', 'inst')
    return
  end
    
  % data may be divided between multiple folders
  if (~iscell(folder))
    folder = {folder};
  end
  
  % get data according to design
  if isempty(design)
    getRegularDataMetaFeatures(folder, opts);
  else
    getDesignedDataMetaFeatures(folder, design);
  end
  
end

function getRegularDataMetaFeatures(folder, settings)
% get metafeatures from data in folder without specified generation design

  % gather all MAT-files
  datalist = {};
  for f = 1:length(folder)
    if isdir(folder{f})
      actualDataList = searchFile(folder{f}, '*.mat');
    elseif isfile(folder{f}) && strcmp(folder{f}(end-3:end), '.mat') 
      actualDataList = folder(f);
    else
      warning('%s is not a directory or MAT-file', folder{f})
      actualDataList = {};
    end
    if numel(actualDataList) > 0
      datalist(end+1 : end+length(actualDataList)) = actualDataList;
    end
  end

  % create feature folder
  % TODO: adaptively create folders according to the original file
  % structure
  outputFolder = defoptsi(settings, 'Output', [folder{1}, '_fts']); 
  [~, ~] = mkdir(outputFolder);
  
  % list through all data
  for dat = 1:length(datalist)
    % load data
    warning('off', 'MATLAB:load:variableNotFound')
    data = load(datalist{dat}, '-mat', 'ds', 'fun', 'dim', 'inst');
    warning('on', 'MATLAB:load:variableNotFound')
    if all(isfield(data, {'ds', 'fun', 'dim', 'inst'}))
      
      % get dataset size (function * dimension * (instances * models))
      [nFun, nDim, instMod] = size(data.ds);
      
      % important information about the dataset to be saved in resulting
      % file
      fun = data.fun;
      dim = data.dim;
      inst = data.inst;
      % save data
      [~, filename] = fileparts(datalist{dat});
      % TODO: check uniqueness of output filenames
      outputFile = fullfile(outputFolder, [filename, '_fts.mat']);
      % try to load result file
      if isfile(outputFile)
        out = load(outputFile, 'res', 'fun', 'dim', 'inst');
      else
        out.res = cell(nFun, nDim, instMod);
      end
      
      res = cell(nFun, nDim, instMod);
      % function loop
      for f = 1:nFun
        % dimension loop
        for d = 1:nDim
          % instance * model loop
          for im = 1:instMod
            countState = sprintf('f%d, %dD, inst*model %d', ...
                                 data.fun(f), data.dim(d), im);
            lState = numel(countState);
            fprintf('%s\n', req(84 + lState))
            fprintf('%s  %s  %s\n', ...
                    req(40), countState, req(40));
            fprintf('%s\n', req(84 + lState))
            % empty output or always rewriting option causes metafeature
            % calculation
            if isempty(out.res{f, d, im}) || opts.rewrite
              % metafeature calculation for different generations
              res{f, d, im} = getSingleDataMF(data.ds{f, d, im}, settings);
              % save results
              save(outputFile, 'res', 'fun', 'dim', 'inst')
            % skip calculation
            else
              fprintf('Already saved in %s\n', outputFile)
            end
          end
        end
      end
      
    else
      fprintf('Variable ''ds'', ''fun'', ''dim'', or ''inst'' not found in %s.\n', datalist{dat})
    end
    
  end

end

function res = getSingleDataMF(ds, opts)
% calculate metafeatures in different generations

  % get generations
  generations = ds.generations;
  nGen = numel(generations);
  
  % generation loop
  for g = 1:nGen
    fprintf('%s  Generation %d (%d/%d) %s\n', ...
            req(40), generations(g), g, nGen, req(40))
    % CMA-ES feature settings
    if any(strcmp(opts.features, 'cmaes'))
      opts.cmaes.cma_cov = ds.BDs{g}*ds.BDs{g}';
      opts.cmaes.cma_evopath_c = ds.pcs{g};
      opts.cmaes.cma_evopath_s = ds.pss{g};
      opts.cmaes.cma_generation = generations(g);
      opts.cmaes.cma_mean = ds.means{g};
      opts.cmaes.cma_restart = ds.iruns(g);
      opts.cmaes.cma_step_size = ds.sigmas{g};
    end
    
    % meta input set loop
    for iSet = 1:numel(opts.metaInput)
      % get correct input
      switch lower(opts.metaInput{iSet})
        case 'archive'
          X = ds.archive.X(ds.archive.gens < generations(g), :);
          y = ds.archive.y(ds.archive.gens < generations(g), :);
        case 'test'
          X = ds.testSetX{g};
          y = NaN(size(X, 1), 1);
        case 'train'
          dsTrain = createTrainDS(ds, generations, g);
          [X, y] = getTrainData(dsTrain, g, opts.trainOpts);
        case {'testtrain', 'traintest'}
          dsTrain = createTrainDS(ds, generations, g);
          [X, y] = getTrainData(dsTrain, g, opts.trainOpts);
          X = [X; ds.testSetX{g}];
          y = [y; NaN(size(ds.testSetX{g}, 1), 1)];
        otherwise
          error('%s is not correct input set name (see help getDataMetafeatures)', ...
                opts.metaInput{iSet})
      end
      % transform data
      if strcmp(opts.transform{iSet}, 'cma') && ~isempty(X)
        X = ( (ds.sigmas{g} * ds.BDs{g}) \ X')';
      end
      % calculate metafeatures
      [res.ft(g).(opts.metaInput{iSet}), values{iSet}] = getMetaFeatures(X, y, opts);
    end
    res.values(:, g) = cell2mat(values');
  end
      
end

function ds = createTrainDS(ds, generations, g)
% create training ds

  % get training archive
  trainArchive = Archive(ds.archive.dim, ds.archive.tolX);
  trainArchive.X = ds.archive.X(ds.archive.gens < generations(g), :);
  trainArchive.y = ds.archive.y(ds.archive.gens < generations(g), :);
  trainArchive.gens = ds.archive.gens(ds.archive.gens < generations(g));
  % create training dataset
  ds.archive = trainArchive;
end

function [X, y] = getTrainData(ds, g, opts)
% get training data for model (derived from DoublyTrainedEC, Model,
% Archive, and Population)
%
% Input:
%   ds   - dataset
%   g    - generation
%   opts - options with following fields:
%
%     evoControlTrainNArchivePoints - number of archive points to be used
%                                     for model training at maximum
%     evoControlTrainRange - range of training set (test set independent)
%                          - used only iff trainSetType == 'parameter'
%     trainRange           - range of training set (test set dependent)
%                          - used only when trainSetType ~= 'parameter'
%     trainsetSizeMax      - maximal size of training set
%     trainSetType         - type of training set | 
%                            {'allpoints', 'clustering', 'nearest', 
%                            'nearesttopopulation', 'parameter', 'recent'}

  % parse options
  opts.evoControlTrainNArchivePoints = ...
    defopts(opts, 'evoControlTrainNArchivePoints', '15*dim');
  opts.evoControlTrainRange = defopts(opts, 'evoControlTrainRange', 10);
  opts.trainRange = defopts(opts, 'trainRange', 1);
  opts.trainsetSizeMax = defopts(opts, 'trainsetSizeMax', '15*dim');
  opts.trainsetType = defopts(opts, 'trainsetType', 'parameters');
 
  % cmaes state variables
  xmean = ds.means{g};
  sigma = ds.sigmas{g};
  BD = ds.BDs{g};
  % dimension can be used in myeval function
  dim = ds.dim;
  
  % population should be object of class Population but structure should be
  % sufficient for getting training data
  population.x = ds.testSetX{g}';
  
  nArchivePoints = myeval(opts.evoControlTrainNArchivePoints);
  if strcmp(opts.trainsetType, 'parameters')
    [X, y] = ds.archive.getDataNearPoint(nArchivePoints, ...
             xmean, opts.evoControlTrainRange, ...
             sigma, BD);
  else
    [X, y] = ds.archive.getTrainsetData(opts.trainsetType,...
             myeval(opts.trainsetSizeMax), xmean, opts.trainRange,...
             sigma, BD, population);
  end
end
  
function getDesignedDataMetaFeatures(folder, design)
% get metafeatures from data in folder generated through specified design

  funIds = 1:24;
  dims = [2, 5, 10];
  instIds = [1:5 41:50];
  Ns = {'50 * dim'};
%   design = {'lhs'};

%   exppath = fullfile('exp', 'experiments');
%   input_path = fullfile(exppath, 'data_metalearn');
  input_path = folder;
  in_fname_template = strjoin({'data_metalearn_', ...
    '%dD_', ...
    'f%d_', ...
    'inst%d_', ...
    'N%d_', ...
    'design-%s.mat'}, '');

  output_path = [folder, '_fts'];
  [~, ~] = mkdir(output_path);
  out_fname_template = 'metafeatures_N-%s_design-%s.mat';

  t0 = tic;
  for N_cell = Ns
    for design_cell = design
      des = design_cell{:};
      % 3d cell for results; N and design type will be distinguished by file name
      mfts = cell(max(dims), max(funIds), max(instIds));

      for dim = dims
        for funId = funIds
          for instId = instIds
            % debug
            fprintf('%dD, f%d, inst%d ...\n', dim, funId, instId);

            % load input data
            N = myeval(N_cell{:});
            in_fname = sprintf(in_fname_template, dim, funId, instId, N, des);
            in_fname = fullfile(input_path, sprintf('%dD', dim), in_fname);
            data = load(in_fname);

            % compute metafeatures
            opts.lb = -5 * ones(1, dim);
            opts.ub = 5 * ones(1, dim);
            opts.features = {'basic', 'cm_angle', 'cm_convexity', ...
                     'cm_gradhomo', 'dispersion', 'ela_distribution', ...
                     'ela_levelset', 'ela_metamodel', 'infocontent', ...
                     'nearest_better', 'pca'};
            [res.ft, res.values] = getMetaFeatures(data.X', data.Y', opts);
            mfts{dim, funId, instId} = res;

            % debug
            fprintf('Elapsed time: %.2f sec.\n', (tic - t0) / 1e6);
          end
        end
      end % dim loop

      % save results
      Nstr = strrep(N_cell{:}, ' * ', '');
      out_fname = sprintf(out_fname_template, Nstr, des);
      out_fname = fullfile(output_path, out_fname);
      save(out_fname, 'funIds', 'dims', 'instIds', 'Ns', 'design', 'mfts');
    end
  end
  
end

function res = req(num)
% row equation symbol
  res = sprintf('%s', ones(1, num)*double('='));
end