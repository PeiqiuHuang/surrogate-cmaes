function getDataMetaFeatures(folder, varargin)
% getDataMetaFeatures(dataname) calculates metafeatures on large set of
% data
% 
% Input:
%   folder   - data input folder
%   settings - pairs of property (string) and value, or struct with 
%              properties as fields:
%     'Design'    - sampling design of source data (use only if data was 
%                   generated by using one) | {'lhs', 'ilhs', 'lhsnorm'}
%     'MetaInput' - input sets for metafeature calculation | {'archive',
%                   'test', 'train', 'test+train'}
%     'TrainOpts' - training set options | structure with fields 
%                   evoControlTrainNArchivePoints, evoControlTrainRange,
%                   trainRange, trainsetSizeMax, and trainSetType
%
% See Also:
%   getMetaFeatures

  
  if nargin < 1
    help getDataMetaFeatures
    return
  end
  
  % parse settings
  settings = settings2struct(varargin{:});
  design = defoptsi(settings, 'Design', '');
  
  % data may be divided between multiple folders
  if (~iscell(folder))
    folder = {folder};
  end
  
  % get data according to design
  if isempty(design)
    getRegularDataMetaFeatures(folder, settings);
  else
    getDesignedDataMetaFeatures(folder, design);
  end
  
end

function getRegularDataMetaFeatures(folder, settings)
% get metafeatures from data in folder without specified generation design
  
  listFeatures = {'basic', ...
                'cm_angle', ...
                'cm_convexity', ...
                'cm_gradhomo', ...
                'cmaes', ...
                'dispersion', ...
                'ela_distribution', ...
                'ela_levelset', ...
                'ela_metamodel', ...
                'gcm', ...
                'infocontent', ...
                'linear_model', ...
                'nearest_better', ...
                'pca' ...
               };

  % parse settings
  opts.lb = defopts(settings, 'lb', '-5*ones(1, dim)');
  opts.ub = defopts(settings, 'ub', ' 5*ones(1, dim)');
  opts.features = defoptsi(settings, 'features', listFeatures);
  opts.metaInput = defoptsi(settings, 'MetaInput', {'archive'});
  opts.trainOpts = defoptsi(settings, 'TrainOpts', struct());

  % gather all MAT-files
  datalist = {};
  for f = 1:length(folder)
    actualDataList = searchFile(folder{f}, '*.mat');
    if numel(actualDataList) > 0
      datalist(end+1 : end+length(actualDataList)) = actualDataList;
    end
  end

  % create feature folder
  % TODO: adaptively create folders according to the original file
  % structure
  outputFolder = [folder{1}, '_fts']; 
  [~, ~] = mkdir(outputFolder);
  
  % list through all data
  for dat = 1:length(datalist)
    % load data
    warning('off', 'MATLAB:load:variableNotFound')
    data = load(datalist{dat}, '-mat', 'ds', 'fun', 'dim', 'inst');
    warning('on', 'MATLAB:load:variableNotFound')
    if all(isfield(data, {'ds', 'fun', 'dim', 'inst'}))
      
      % get dataset size (function * dimension * (instances * models))
      [nFun, nDim, instMod] = size(data.ds);
      
      res = cell(nFun, nDim, instMod);
      % function loop
      for f = 1:nFun
        % dimension loop
        for d = 1:nDim
          % instance * model loop
          for im = 1:instMod
            % metafeature calculation for different generations
            res{f, d, im} = getSingleDataMF(data.ds{f, d, im}, opts);
          end
        end
      end
      
      % important information about the dataset to be saved in resulting
      % file
      fun = data.fun;
      dim = data.dim;
      inst = data.inst;
      % save data
      [~, filename] = fileparts(datalist{dat});
      % TODO: check uniqueness of output filenames
      outputFile = fullfile(outputFolder, [filename, '_fts.mat']);
      save(outputFile, 'res', 'fun', 'dim', 'inst')
    else
      fprintf('Variable ''ds'', ''fun'', ''dim'', or ''inst'' not found in %s.\n', datalist{dat})
    end
    
  end

end

function res = getSingleDataMF(ds, opts)
% calculate metafeatures in different generations

  % get generations
  generations = ds.generations;
  nGen = numel(generations);
  
  % generation loop
  for g = 1:nGen
    % CMA-ES feature settings
    if any(strcmp(opts.features, 'cmaes'))
      opts.cmaes.cma_cov = ds.BDs{g}*ds.BDs{g}';
      opts.cmaes.cma_evopath_c = ds.pcs{g};
      opts.cmaes.cma_evopath_s = ds.pss{g};
      opts.cmaes.cma_generation = generations(g);
      opts.cmaes.cma_mean = ds.means{g};
      opts.cmaes.cma_restart = ds.iruns(g);
      opts.cmaes.cma_step_size = ds.sigmas{g};
    end
    
    % meta input set loop
    for iSet = 1:numel(opts.metaInput)
      % get correct input
      switch opts.metaInput{iSet}
        case 'archive'
          X = ds.archive.X(ds.archive.gens < generations(g), :);
          y = ds.archive.y(ds.archive.gens < generations(g), :);
        case 'test'
          X = ds.testSetX{g};
          y = NaN(size(X, 1), 1);
        case 'train'
          dsTrain = createTrainDS(ds, generations, g);
          [X, y] = getTrainData(dsTrain, g, opts.trainOpts);
        case {'test+train', 'train+test'}
          dsTrain = createTrainDS(ds, generations, g);
          [X, y] = getTrainData(dsTrain, g, opts.trainOpts);
          X = [X; ds.testSetX{g}];
          y = [y; NaN(size(X, 1), 1)];
      end
      % calculate metafeatures
      [res.ft(g).(opts.metaInput{iSet}), values{iSet}] = getMetaFeatures(X, y, opts);
    end
    res.values(:, g) = cell2mat(values');
  end
      
end

function ds = createTrainDS(ds, generations, g)
% create training ds

  % get training archive
  trainArchive = Archive(ds.archive.dim, ds.archive.tolX);
  trainArchive.X = ds.archive.X(ds.archive.gens < generations(g), :);
  trainArchive.y = ds.archive.y(ds.archive.gens < generations(g), :);
  trainArchive.gens = ds.archive.gens(ds.archive.gens < generations(g));
  % create training dataset
  ds.archive = trainArchive;
end

function [X, y] = getTrainData(ds, g, opts)
% get training data for model (derived from DoublyTrainedEC, Model,
% Archive, and Population)
%
% Input:
%   ds   - dataset
%   g    - generation
%   opts - options with following fields:
%
%     evoControlTrainNArchivePoints - number of archive points to be used
%                                     for model training at maximum
%     evoControlTrainRange - range of training set (test set independent)
%                          - used only iff trainSetType == 'parameter'
%     trainRange           - range of training set (test set dependent)
%                          - used only when trainSetType ~= 'parameter'
%     trainsetSizeMax      - maximal size of training set
%     trainSetType         - type of training set | 
%                            {'allpoints', 'clustering', 'nearest', 
%                            'nearesttopopulation', 'parameter', 'recent'}

  % parse options
  opts.evoControlTrainNArchivePoints = ...
    defopts(opts, 'evoControlTrainNArchivePoints', '15*dim');
  opts.evoControlTrainRange = defopts(opts, 'evoControlTrainRange', 10);
  opts.trainRainge = defopts(opts, 'trainRange', 1);
  opts.trainsetSizeMax = defopts(opts, 'trainsetSizeMax', '15*dim');
  opts.trainsetType = defopts(opts, 'trainsetType', 'parameters');
 
  % cmaes state variables
  xmean = ds.means{g};
  sigma = ds.sigmas{g};
  BD = ds.BDs{g};
  % dimension can be used in myeval function
  dim = ds.dim;
  
  % population should be object of class Population but structure should be
  % sufficient for getting training data
  population.x = ds.testSetX{g};
  
  nArchivePoints = myeval(opts.evoControlTrainNArchivePoints);
  if strcmp(opts.trainsetType, 'parameters')
    [X, y] = ds.archive.getDataNearPoint(nArchivePoints, ...
             xmean, opts.evoControlTrainRange, ...
             sigma, BD);
  else
    [X, y] = ds.archive.getTrainsetData(opts.trainsetType,...
             myeval(opts.trainsetSizeMax), xmean, opts.trainRange,...
             sigma, BD, population);
  end
end
  
function getDesignedDataMetaFeatures(folder, design)
% get metafeatures from data in folder generated through specified design

  funIds = 1:24;
  dims = [2, 5, 10];
  instIds = [1:5 41:50];
  Ns = {'50 * dim'};
%   design = {'lhs'};

%   exppath = fullfile('exp', 'experiments');
%   input_path = fullfile(exppath, 'data_metalearn');
  input_path = folder;
  in_fname_template = strjoin({'data_metalearn_', ...
    '%dD_', ...
    'f%d_', ...
    'inst%d_', ...
    'N%d_', ...
    'design-%s.mat'}, '');

  output_path = [folder, '_fts'];
  [~, ~] = mkdir(output_path);
  out_fname_template = 'metafeatures_N-%s_design-%s.mat';

  t0 = tic;
  for N_cell = Ns
    for design_cell = design
      des = design_cell{:};
      % 3d cell for results; N and design type will be distinguished by file name
      mfts = cell(max(dims), max(funIds), max(instIds));

      for dim = dims
        for funId = funIds
          for instId = instIds
            % debug
            fprintf('%dD, f%d, inst%d ...\n', dim, funId, instId);

            % load input data
            N = myeval(N_cell{:});
            in_fname = sprintf(in_fname_template, dim, funId, instId, N, des);
            in_fname = fullfile(input_path, sprintf('%dD', dim), in_fname);
            data = load(in_fname);

            % compute metafeatures
            opts.lb = -5 * ones(1, dim);
            opts.ub = 5 * ones(1, dim);
            opts.features = {'basic', 'cm_angle', 'cm_convexity', ...
                     'cm_gradhomo', 'dispersion', 'ela_distribution', ...
                     'ela_levelset', 'ela_metamodel', 'infocontent', ...
                     'nearest_better', 'pca'};
            [res.ft, res.values] = getMetaFeatures(data.X', data.Y', opts);
            mfts{dim, funId, instId} = res;

            % debug
            fprintf('Elapsed time: %.2f sec.\n', (tic - t0) / 1e6);
          end
        end
      end % dim loop

      % save results
      Nstr = strrep(N_cell{:}, ' * ', '');
      out_fname = sprintf(out_fname_template, Nstr, des);
      out_fname = fullfile(output_path, out_fname);
      save(out_fname, 'funIds', 'dims', 'instIds', 'Ns', 'design', 'mfts');
    end
  end
  
end
